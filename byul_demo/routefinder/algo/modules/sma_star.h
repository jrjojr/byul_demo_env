#ifndef SMA_STAR_H
#define SMA_STAR_H

#include "../algo.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef struct s_sma_star_config{
    gint memory_limit;  ///< ìµœëŒ€ í—ˆìš© ê°€ëŠ¥í•œ ë…¸ë“œ ìˆ˜
} sma_star_config_t;

typedef sma_star_config_t* sma_star_config;

/**
 * @brief SMA* ì„¤ì • ê°ì²´ ìƒì„± (ê¸°ë³¸ ë©”ëª¨ë¦¬ ì œí•œ: 1000 ë…¸ë“œ)
 */
BYUL_API sma_star_config sma_star_config_new();

/**
 * @brief SMA* (Simplified Memory-Bounded A*) ì•Œê³ ë¦¬ì¦˜ì—ì„œ ì‚¬ìš©í• 
 *        ë©”ëª¨ë¦¬ ì œí•œ ì„¤ì • ê°ì²´ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
 *
 * SMA*ëŠ” ì „í†µì ì¸ A* ì•Œê³ ë¦¬ì¦˜ê³¼ ìœ ì‚¬í•˜ê²Œ íœ´ë¦¬ìŠ¤í‹± ê¸°ë°˜ì˜ ìµœë‹¨ ê²½ë¡œ íƒìƒ‰ì„ ìˆ˜í–‰í•˜ì§€ë§Œ,
 * ì‚¬ìš© ê°€ëŠ¥í•œ ë©”ëª¨ë¦¬ë¥¼ ì œí•œí•˜ì—¬, ë©”ëª¨ë¦¬ë¥¼ ì´ˆê³¼í•˜ëŠ” ê²½ìš° ìš°ì„ ìˆœìœ„ê°€ ë‚®ì€ ë…¸ë“œë¥¼ ì‚­ì œí•˜ê³ 
 * ê²½ë¡œë¥¼ ì¬íƒìƒ‰í•˜ëŠ” êµ¬ì¡°ì…ë‹ˆë‹¤.
 *
 * ì´ í•¨ìˆ˜ëŠ” SMA* ì•Œê³ ë¦¬ì¦˜ì— ì‚¬ìš©í•  ë©”ëª¨ë¦¬ ì œí•œì„ ì§ì ‘ ì„¤ì •í•˜ë©°,
 * ì„¤ì •ëœ memory_limit ê°’ì€ frontier(ìš°ì„ ìˆœìœ„ í)ì— 
 * ìœ ì§€ ê°€ëŠ¥í•œ ìµœëŒ€ ë…¸ë“œ ìˆ˜ë¥¼ ì˜ë¯¸í•©ë‹ˆë‹¤.
 *
 * ë©”ëª¨ë¦¬ ì œí•œì€ íƒìƒ‰ ì„±ëŠ¥ê³¼ ì§ì ‘ì ì¸ ê´€ê³„ê°€ ìˆìœ¼ë©°, ë‹¤ìŒê³¼ ê°™ì€ ì›ì¹™ì´ ì ìš©ë©ë‹ˆë‹¤:
 *
 * - ì œí•œì´ ë‚®ì„ìˆ˜ë¡ ê²½ë¡œ íƒìƒ‰ ì‹¤íŒ¨ í™•ë¥ ì´ ë†’ì•„ì§€ê³ , ê²½ë¡œ í’ˆì§ˆì´ ì €í•˜ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
 * - ì œí•œì´ ë†’ì„ìˆ˜ë¡ A*ì— ê°€ê¹Œìš´ íƒìƒ‰ í’ˆì§ˆì„ ë³´ì¥í•˜ë©°, 
 *      íŠ¸ë¦¬ë°ì´ ë°œìƒí•˜ì§€ ì•Šìœ¼ë¯€ë¡œ ì•ˆì •ì ì…ë‹ˆë‹¤.
 * - ë©”ëª¨ë¦¬ê°€ ë„ˆë¬´ ë‚®ì„ ê²½ìš° (ì˜ˆ: 0 ë˜ëŠ” 1), 
 *      ì‹œì‘ ë…¸ë“œ ì™¸ì—ëŠ” ì•„ë¬´ ê²ƒë„ ìœ ì§€í•˜ì§€ ëª»í•˜ë¯€ë¡œ,
 *   ë§µ í¬ê¸°ë‚˜ ì¥ì• ë¬¼ ë³µì¡ë„ì— ë”°ë¼ íƒìƒ‰ ìì²´ê°€ ë¶ˆê°€ëŠ¥í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
 *
 * ğŸ”¢ ë©”ëª¨ë¦¬ ì œí•œê³¼ ë§µ í¬ê¸°ì˜ ì¼ë°˜ì  ê´€ê³„ (ê²½í—˜ì  ê¸°ì¤€):
 *
 * - ë§µ í¬ê¸°: `N = width Ã— height`
 * - ìµœë‹¨ ê²½ë¡œ ê¸¸ì´: `L` (ëŒ€ê°ì„  í¬í•¨ ì•½ 2Ã—N^0.5)
 *
 * ê¶Œì¥ ê³µì‹:
 * @code
 * memory_limit â‰ˆ max(L Ã— (1 + Îµ), N Ã— Î±)
 * // Îµ âˆˆ [0.5, 1.0], Î± âˆˆ [0.01, 0.05]
 * @endcode
 *
 * ì˜ˆì‹œ:
 * - ë§µ 100Ã—100 (N=10,000): memory_limit 1000~2000 ì´ìƒ ê¶Œì¥
 * - ë§µ 1000Ã—1000 (N=1,000,000): memory_limit 10,000~50,000 ì´ìƒ ì¶”ì²œ
 *
 * @param memory_limit ìœ ì§€ ê°€ëŠ¥í•œ ìµœëŒ€ ë…¸ë“œ ìˆ˜ (0 ì´ìƒ, 0ì´ë©´ íƒìƒ‰ ì‹¤íŒ¨ ê°€ëŠ¥ì„± ë†’ìŒ)
 * @return sma_star_config ì„¤ì • ê°ì²´ (í•´ì œ ì‹œ sma_star_config_free() ì‚¬ìš©)
 */
BYUL_API sma_star_config sma_star_config_new_full(gint memory_limit);

/**
 * @brief SMA* ì„¤ì • ê°ì²´ í•´ì œ
 */
BYUL_API void sma_star_config_free(sma_star_config cfg);

/**
 * @brief SMA* ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•˜ì—¬ ë©”ëª¨ë¦¬ ì œí•œ í•˜ì— ìµœë‹¨ ê²½ë¡œë¥¼ íƒìƒ‰í•©ë‹ˆë‹¤.
 *
 * SMA* (Simplified Memory-Bounded A*)ëŠ” ì „í†µì ì¸ A* ì•Œê³ ë¦¬ì¦˜ê³¼ ìœ ì‚¬í•˜ê²Œ
 * f = g + h ê¸°ë°˜ì˜ ìš°ì„ ìˆœìœ„ íƒìƒ‰ì„ ìˆ˜í–‰í•˜ì§€ë§Œ, 
 * ì£¼ì–´ì§„ ë©”ëª¨ë¦¬ ì œí•œ(memory_limit) ë‚´ì—ì„œë§Œ
 * frontier ë…¸ë“œë¥¼ ìœ ì§€í•˜ë©°, 
 * ì´ˆê³¼ ì‹œ ìš°ì„ ìˆœìœ„(fê°’)ê°€ ê°€ì¥ ë†’ì€ ë…¸ë“œë¥¼ ì œê±°í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ ì‘ë™í•©ë‹ˆë‹¤.
 *
 * ë©”ëª¨ë¦¬ ì œí•œì´ ì¶©ë¶„í•  ê²½ìš°, A*ì™€ ìœ ì‚¬í•œ ê²½ë¡œ í’ˆì§ˆì„ ë³´ì¥í•˜ì§€ë§Œ,
 * ì œí•œì´ ì‘ì„ìˆ˜ë¡ ë” ë§ì€ ë…¸ë“œê°€ ì‚­ì œ(trimming)ë˜ë©°, 
 * ê²½ë¡œ í’ˆì§ˆì´ ë‚®ì•„ì§€ê±°ë‚˜ íƒìƒ‰ì— ì‹¤íŒ¨í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
 *
 * ì œê±°ëœ ë…¸ë“œëŠ” `came_from` ê¸°ë¡ì„ ìœ ì§€í•˜ì§€ ì•Šê¸° ë•Œë¬¸ì—,
 * ì˜ëª»ëœ ë°©í–¥ìœ¼ë¡œ ì§„í–‰ë˜ê±°ë‚˜, 
 * ì´ë¯¸ ì§€ë‚˜ì˜¨ ê²½ë¡œë¥¼ ë³µêµ¬í•˜ì§€ ëª»í•˜ëŠ” ìƒí™©ì´ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
 *
 * ì‹¤ì „ ì‚¬ìš© ì‹œ memory_limitì€ ë§µ í¬ê¸°ì™€ ê²½ë¡œ ë³µì¡ë„ì— ë”°ë¼ ì¡°ì •í•´ì•¼ í•©ë‹ˆë‹¤.
 * ì¼ë°˜ì ìœ¼ë¡œ ê²½ë¡œ ê¸¸ì´ì˜ 3~10ë°°, 
 * ë˜ëŠ” ë§µì˜ 1~5% ì •ë„ ë©”ëª¨ë¦¬ë¥¼ í™•ë³´í•˜ë©´ ì•ˆì •ì ì¸ íƒìƒ‰ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤.
 *
 * ì˜ˆì œ: ë©”ëª¨ë¦¬ ì œí•œì´ 10ì¸ ìƒíƒœì—ì„œ ì¤‘ì•™ì— ìˆ˜ì§ ì¥ì• ë¬¼ì´ ì¡´ì¬í•˜ëŠ” 10x10 ë§µ
 * (5ì—´ ì°¨ë‹¨)ì„ íƒìƒ‰í•  ê²½ìš°, ìš°íšŒ ê²½ë¡œë¥¼ ì„±ê³µì ìœ¼ë¡œ ì°¾ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
 *
 * @code
 * coord start = coord_new_full(0, 0);
 * coord goal   = coord_new_full(9, 9);
 *
 * sma_star_config cfg = sma_star_config_new_full(10); // ì œí•œëœ ë©”ëª¨ë¦¬
 * algo al = algo_new_full(
 *     10, 10,
 *     MAP_NEIGHBOR_8,
 *     PATH_ALGO_SMA_STAR,
 *     default_cost,
 *     default_heuristic,
 *     NULL,
 *     cfg,
 *     TRUE
 * );
 *
 * for (int y = 1; y < 10; y++)
 *     map_block_coord(al->m, 5, y); // ì¤‘ì•™ ì°¨ë‹¨
 *
 * route p = algo_find(al, start, goal);
 * g_assert_true(route_get_success(p));
 * map_print_ascii_with_visited_count(al->m, p, start, goal);
 * @endcode
 *
 * @param al    ì•Œê³ ë¦¬ì¦˜ ì»¨í…ìŠ¤íŠ¸ (algo_new_fullë¡œ ìƒì„±)
 * @param start  ì‹œì‘ ì¢Œí‘œ
 * @param goal    ë„ì°© ì¢Œí‘œ
 * @return íƒìƒ‰ ê²°ê³¼ route. ì„±ê³µ ì‹œ route_get_success(route) == TRUE.
 *         ì‹¤íŒ¨ ì‹œ success == FALSEì´ë©°, routeëŠ” ë¹„ì–´ ìˆì„ ìˆ˜ ìˆìŒ.
 */
BYUL_API route sma_star_find(const algo al, const coord start, const coord goal);

#ifdef __cplusplus
}
#endif

#endif // SMA_STAR_H
